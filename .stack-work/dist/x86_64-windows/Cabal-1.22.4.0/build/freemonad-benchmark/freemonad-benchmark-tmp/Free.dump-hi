
==================== FINAL INTERFACE ====================
2016-01-04 15:50:40.6142012 UTC

interface main@main:Free 7102
  interface hash: 2b155768301813bad09976ca0ded677d
  ABI hash: 069f43e8af79f31a76118780d3291a01
  export-list hash: edaba532e6f5b030b282aaf38146d7bb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: fc0f3b0772c2c504b379b256c26a40cd
  sig of: Nothing
  used TH splices: False
  where
exports:
  Free.run
  Free.runLazily
  Free.Free{Free.Free Free.Pure}
module dependencies: Base
package dependencies: Win32-2.3.1.0@Win32_JH0ECVJdFmmG0JOvttvGqi
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
                      lifted-base-0.2.3.6@lifte_K3cQFA6mRg85rpDaA9numU
                      mmorph-1.0.4@mmorp_8dNpUU8QFPe77rrwKAb20b
                      monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo
                      time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      transformers-base-0.4.4@trans_88TAFm21vtn2NrYUppy50c
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming.Prelude
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Format.Parse
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b:Control.Monad.Trans.Control
                         resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS:Control.Monad.Trans.Resource.Internal
import  -/  base-4.8.1.0:Control.Applicative a283901553892ce761385d18e455c2ce
import  -/  base-4.8.1.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  Base 4539c1b83b5f5c3bc3a6d6f65d743fb2
  exports: 8763dd5bae4f40ca274cc839ac61fcf9
  F b260b91cf94c568dd588600cb83d719c
  F 7cbec1f8f3194174f75be33e5b893b9f
  MonadFree 214a069f1b90a7dfdbb158c26b94063c
  wrap 934c5269797907e84f278b415b88a6c3
53cc26b8bb4ac6b4bc91cff9e377c042
  $fApplicativeFree ::
    (GHC.Base.Functor (Free.Free f), GHC.Base.Functor f) =>
    GHC.Base.Applicative (Free.Free f)
  DFunId[1]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U,U)><L,U(C(C1(U)),A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dFunctor :: GHC.Base.Functor (Free.Free f)
                      $dFunctor1 :: GHC.Base.Functor f.
                  @ (Free.Free f)
                  $dFunctor
                  (Free.Pure @ f)
                  (Free.$fApplicativeFree_$c<*> @ f $dFunctor $dFunctor1)
                  (Free.$fApplicativeFree_$c*> @ f $dFunctor $dFunctor1)
                  (Free.$fApplicativeFree_$c<* @ f $dFunctor $dFunctor1) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fApplicativeFree_$c*> ::
    (GHC.Base.Functor (Free.Free f), GHC.Base.Functor f) =>
    forall a b. Free.Free f a -> Free.Free f b -> Free.Free f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))),U(C(U),1*C1(C1(U)))><L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Free.Free f)
                   $dFunctor1 :: GHC.Base.Functor f
                   @ a
                   @ b
                   eta :: Free.Free f a
                   eta1 :: Free.Free f b ->
                 Free.$fApplicativeFree_$c<*>
                   @ f
                   $dFunctor
                   $dFunctor1
                   @ b
                   @ b
                   (GHC.Base.<$
                      @ (Free.Free f)
                      $dFunctor
                      @ (b -> b)
                      @ a
                      (GHC.Base.id @ b)
                      eta)
                   eta1) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fApplicativeFree_$c<* ::
    (GHC.Base.Functor (Free.Free f), GHC.Base.Functor f) =>
    forall a b. Free.Free f a -> Free.Free f b -> Free.Free f a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(U),A)><L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Free.Free f)
                   $dFunctor1 :: GHC.Base.Functor f
                   @ a
                   @ b
                   eta :: Free.Free f a
                   eta1 :: Free.Free f b ->
                 Free.$fApplicativeFree_$c<*>
                   @ f
                   $dFunctor
                   $dFunctor1
                   @ b
                   @ a
                   (GHC.Base.fmap
                      @ (Free.Free f)
                      $dFunctor
                      @ a
                      @ (b -> a)
                      (GHC.Base.const @ a @ b)
                      eta)
                   eta1) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fApplicativeFree_$c<*> ::
    (GHC.Base.Functor (Free.Free f), GHC.Base.Functor f) =>
    forall a b. Free.Free f (a -> b) -> Free.Free f a -> Free.Free f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(U),A)><L,U(C(C1(U)),A)><S,1*U><L,U> -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fFunctorFree ::
    GHC.Base.Functor f => GHC.Base.Functor (Free.Free f)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *) $dFunctor :: GHC.Base.Functor f.
                  @ (Free.Free f)
                  (Free.$fFunctorFree_$cfmap @ f $dFunctor)
                  (Free.$fFunctorFree_$c<$ @ f $dFunctor) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fFunctorFree_$c<$ ::
    GHC.Base.Functor f =>
    forall a b. a -> Free.Free f b -> Free.Free f a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U>,
     Unfolding: (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   @ b
                   eta :: a
                   eta1 :: Free.Free f b ->
                 let {
                   lvl1 :: Free.Free f a = Free.Pure @ f @ a eta
                 } in
                 letrec {
                   go :: Free.Free f b -> Free.Free f a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: Free.Free f b ->
                     case ds of wild {
                       Free.Pure a1 -> lvl1
                       Free.Free fa
                       -> Free.Free
                            @ f
                            @ a
                            (GHC.Base.fmap
                               @ f
                               $dFunctor
                               @ (Free.Free f b)
                               @ (Free.Free f a)
                               go
                               fa) }
                 } in
                 go eta1) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fFunctorFree_$cfmap ::
    GHC.Base.Functor f =>
    forall a b. (a -> b) -> Free.Free f a -> Free.Free f b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   @ b
                   f1 :: a -> b
                   eta :: Free.Free f a ->
                 letrec {
                   go :: Free.Free f a -> Free.Free f b {- Arity: 1 -}
                   = \ ds :: Free.Free f a ->
                     case ds of wild {
                       Free.Pure a1 -> Free.Pure @ f @ b (f1 a1)
                       Free.Free fa
                       -> Free.Free
                            @ f
                            @ b
                            (Data.Functor.<$>
                               @ (Free.Free f a)
                               @ (Free.Free f b)
                               @ f
                               $dFunctor
                               go
                               fa) }
                 } in
                 go eta) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFree ::
    (GHC.Base.Applicative (Free.Free f), GHC.Base.Functor f) =>
    GHC.Base.Monad (Free.Free f)
  DFunId[1]
  {- Arity: 2, Strictness: <L,U><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dApplicative :: GHC.Base.Applicative (Free.Free f)
                      $dFunctor :: GHC.Base.Functor f.
                  @ (Free.Free f)
                  $dApplicative
                  (Free.$fMonadFree_$c>>= @ f $dApplicative $dFunctor)
                  (Free.$fMonadFree_$c>> @ f $dApplicative $dFunctor)
                  (Free.Pure @ f)
                  (Free.$fMonadFree_$cfail @ f $dApplicative $dFunctor) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFree_$c>> ::
    (GHC.Base.Applicative (Free.Free f), GHC.Base.Functor f) =>
    forall a b. Free.Free f a -> Free.Free f b -> Free.Free f b
  {- Arity: 4, Strictness: <L,U><L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (4, False, False)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Free.Free f)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   @ b
                   m1 :: Free.Free f a
                   k :: Free.Free f b ->
                 Free.$fMonadFree_$c>>=
                   @ f
                   $dApplicative
                   $dFunctor
                   @ a
                   @ b
                   m1
                   (\ ds :: a -> k)) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFree_$c>>= ::
    (GHC.Base.Applicative (Free.Free f), GHC.Base.Functor f) =>
    forall a b. Free.Free f a -> (a -> Free.Free f b) -> Free.Free f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C1(U)),A)><S,1*U><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, True)
                (\ @ (f :: * -> *)
                   w :: GHC.Base.Applicative (Free.Free f)
                   w1 :: GHC.Base.Functor f
                   @ a
                   @ b
                   w2 :: Free.Free f a
                   w3 :: a -> Free.Free f b ->
                 Free.$w$c>>= @ f w1 @ a @ b w2 w3) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFree_$cfail ::
    (GHC.Base.Applicative (Free.Free f), GHC.Base.Functor f) =>
    forall a. GHC.Base.String -> Free.Free f a
  {- Arity: 3, Strictness: <B,A><B,A><B,U>b,
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Free.Free f)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   eta :: [GHC.Types.Char] ->
                 GHC.Err.error @ (Free.Free f a) eta) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFreefFree ::
    (GHC.Base.Monad (Free.Free f), GHC.Base.Functor f) =>
    Base.MonadFree f (Free.Free f)
  DFunId[1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dMonad :: GHC.Base.Monad (Free.Free f)
                      $dFunctor :: GHC.Base.Functor f.
                  @ f
                  @ (Free.Free f)
                  $dMonad
                  (Free.$fMonadFreefFree_$cwrap @ f $dMonad $dFunctor) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $fMonadFreefFree_$cwrap ::
    (GHC.Base.Monad (Free.Free f), GHC.Base.Functor f) =>
    forall a. f (Free.Free f a) -> Free.Free f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (f :: * -> *)
                   $dMonad :: GHC.Base.Monad (Free.Free f)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   eta :: f (Free.Free f a) ->
                 Free.Free @ f @ a eta) -}
53cc26b8bb4ac6b4bc91cff9e377c042
  $w$c>>= ::
    GHC.Base.Functor f =>
    forall a b. Free.Free f a -> (a -> Free.Free f b) -> Free.Free f b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,C(U)>, Inline: [0] -}
37c83d5f3e61c1655eea667b3160c988
  $wrun ::
    Free.Free Base.F a -> GHC.Types.Int -> (# GHC.Types.Int, a #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
53cc26b8bb4ac6b4bc91cff9e377c042
  type role Free nominal nominal
  data Free (f :: * -> *) a = Pure a | Free (f (Free.Free f a))
6f7ff988d41a671834135f8067707010
  run :: Free.Free Base.F a -> GHC.Types.Int -> (GHC.Types.Int, a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: Free.Free Base.F a w1 :: GHC.Types.Int ->
                 case Free.$wrun @ a w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
e7c8c314b2916909574d48bfa222e301
  runLazily ::
    Free.Free Base.F a -> GHC.Types.Int -> (GHC.Types.Int, a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: Free.Free Base.F a w1 :: GHC.Types.Int ->
                 case w of wild {
                   Free.Pure x -> (w1, x)
                   Free.Free ds
                   -> case ds of wild1 { Base.F a1 ->
                      case a1 w1 of ww { (,) ww1 ww2 ->
                      case Free.$wrun @ a ww2 ww1 of ww3 { (#,#) ww4 ww5 ->
                      (ww4, ww5) } } } }) -}
instance GHC.Base.Applicative [Free.Free] = Free.$fApplicativeFree
instance GHC.Base.Functor [Free.Free] = Free.$fFunctorFree
instance GHC.Base.Monad [Free.Free] = Free.$fMonadFree
instance Base.MonadFree [., Free.Free] = Free.$fMonadFreefFree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

