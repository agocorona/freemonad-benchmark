
==================== FINAL INTERFACE ====================
2016-01-04 15:50:43.2285159 UTC

interface main@main:Freer 7102
  interface hash: 6e3a292f138b59c4099f8edd78ad484c
  ABI hash: 24425fd8326842e31741a0b61861d425
  export-list hash: c3f7eab32885e9bd4378f22055a921c7
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 3993c5deecb473f34c66df1bf32f3df4
  sig of: Nothing
  used TH splices: False
  where
exports:
  Freer.fold
  Freer.run
  Freer.Free{Freer.Impure Freer.Pure}
module dependencies: Base
package dependencies: Win32-2.3.1.0@Win32_JH0ECVJdFmmG0JOvttvGqi
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
                      lifted-base-0.2.3.6@lifte_K3cQFA6mRg85rpDaA9numU
                      mmorph-1.0.4@mmorp_8dNpUU8QFPe77rrwKAb20b
                      monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo
                      time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      transformers-base-0.4.4@trans_88TAFm21vtn2NrYUppy50c
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming.Prelude
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Format.Parse
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b:Control.Monad.Trans.Control
                         resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS:Control.Monad.Trans.Resource.Internal
import  -/  base-4.8.1.0:Control.Monad dfea142d91349c4861427789d50d5b80
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  Base 4539c1b83b5f5c3bc3a6d6f65d743fb2
  exports: 8763dd5bae4f40ca274cc839ac61fcf9
  F b260b91cf94c568dd588600cb83d719c
  F 7cbec1f8f3194174f75be33e5b893b9f
  MonadFree 214a069f1b90a7dfdbb158c26b94063c
  wrap 934c5269797907e84f278b415b88a6c3
a0eb37a889b29470dd0991ecc3fcca1f
  $fApplicativeFree ::
    GHC.Base.Functor (Freer.Free f) =>
    GHC.Base.Applicative (Freer.Free f)
  DFunId[1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dFunctor :: GHC.Base.Functor (Freer.Free f).
                  @ (Freer.Free f)
                  $dFunctor
                  (Freer.$fApplicativeFree_$cpure @ f $dFunctor)
                  (Freer.$fApplicativeFree_$c<*> @ f $dFunctor)
                  (Freer.$fApplicativeFree_$c*> @ f $dFunctor)
                  (Freer.$fApplicativeFree_$c<* @ f $dFunctor) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fApplicativeFree_$c*> ::
    GHC.Base.Functor (Freer.Free f) =>
    forall a b. Freer.Free f a -> Freer.Free f b -> Freer.Free f b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U,U)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Freer.Free f)
                   @ a
                   @ b
                   eta :: Freer.Free f a
                   eta1 :: Freer.Free f b ->
                 Freer.$fApplicativeFree_$c<*>
                   @ f
                   $dFunctor
                   @ b
                   @ b
                   (GHC.Base.<$
                      @ (Freer.Free f)
                      $dFunctor
                      @ (b -> b)
                      @ a
                      (GHC.Base.id @ b)
                      eta)
                   eta1) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fApplicativeFree_$c<* ::
    GHC.Base.Functor (Freer.Free f) =>
    forall a b. Freer.Free f a -> Freer.Free f b -> Freer.Free f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U,U)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Freer.Free f)
                   @ a
                   @ b
                   eta :: Freer.Free f a
                   eta1 :: Freer.Free f b ->
                 Freer.$fApplicativeFree_$c<*>
                   @ f
                   $dFunctor
                   @ b
                   @ a
                   (GHC.Base.fmap
                      @ (Freer.Free f)
                      $dFunctor
                      @ a
                      @ (b -> a)
                      (GHC.Base.const @ a @ b)
                      eta)
                   eta1) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fApplicativeFree_$c<*> ::
    GHC.Base.Functor (Freer.Free f) =>
    forall a b.
    Freer.Free f (a -> b) -> Freer.Free f a -> Freer.Free f b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U,U)>,
     Unfolding: (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Freer.Free f)
                   @ a
                   @ b
                   eta :: Freer.Free f (a -> b)
                   eta1 :: Freer.Free f a ->
                 Freer.$w$c>>=
                   @ f
                   @ (a -> b)
                   @ b
                   eta
                   (\ x1 :: a -> b ->
                    Freer.$w$c>>=
                      @ f
                      @ a
                      @ b
                      eta1
                      (\ x2 :: a -> Freer.Pure @ f @ b (x1 x2)))) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fApplicativeFree_$cpure ::
    GHC.Base.Functor (Freer.Free f) => forall a. a -> Freer.Free f a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Freer.Free f)
                   @ a
                   eta :: a ->
                 Freer.Pure @ f @ a eta) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fFunctorFree :: GHC.Base.Functor (Freer.Free f)
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *).
                  @ (Freer.Free f)
                  (Freer.$fFunctorFree_$cfmap @ f)
                  (Freer.$fFunctorFree_$c<$ @ f) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fFunctorFree_$c<$ :: a -> Freer.Free f b -> Freer.Free f a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (f :: * -> *) @ a @ b eta :: a eta1 :: Freer.Free f b ->
                 Freer.$fFunctorFree_$cfmap @ f @ b @ a (\ ds :: b -> eta) eta1) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fFunctorFree_$cfmap ::
    (a -> b) -> Freer.Free f a -> Freer.Free f b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   @ b
                   f1 :: a -> b
                   m1 :: Freer.Free f a ->
                 Freer.$w$c>>=
                   @ f
                   @ a
                   @ b
                   m1
                   (\ x1 :: a -> Freer.Pure @ f @ b (f1 x1))) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFree ::
    GHC.Base.Applicative (Freer.Free f) =>
    GHC.Base.Monad (Freer.Free f)
  DFunId[1]
  {- Arity: 1, Strictness: <L,U>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dApplicative :: GHC.Base.Applicative (Freer.Free f).
                  @ (Freer.Free f)
                  $dApplicative
                  (Freer.$fMonadFree_$c>>= @ f $dApplicative)
                  (Freer.$fMonadFree_$c>> @ f $dApplicative)
                  (Freer.$fMonadFree_$creturn @ f $dApplicative)
                  (Freer.$fMonadFree_$cfail @ f $dApplicative) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFree_$c>> ::
    GHC.Base.Applicative (Freer.Free f) =>
    forall a b. Freer.Free f a -> Freer.Free f b -> Freer.Free f b
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Freer.Free f)
                   @ a
                   @ b
                   m1 :: Freer.Free f a
                   k :: Freer.Free f b ->
                 Freer.$fMonadFree_$c>>=
                   @ f
                   $dApplicative
                   @ a
                   @ b
                   m1
                   (\ ds :: a -> k)) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFree_$c>>= ::
    GHC.Base.Applicative (Freer.Free f) =>
    forall a b.
    Freer.Free f a -> (a -> Freer.Free f b) -> Freer.Free f b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   w :: GHC.Base.Applicative (Freer.Free f)
                   @ a
                   @ b
                   w1 :: Freer.Free f a
                   w2 :: a -> Freer.Free f b ->
                 Freer.$w$c>>= @ f @ a @ b w1 w2) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFree_$cfail ::
    GHC.Base.Applicative (Freer.Free f) =>
    forall a. GHC.Base.String -> Freer.Free f a
  {- Arity: 2, Strictness: <B,A><B,U>b,
     Unfolding: InlineRule (2, True, True)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Freer.Free f)
                   @ a
                   eta :: [GHC.Types.Char] ->
                 GHC.Err.error @ (Freer.Free f a) eta) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFree_$creturn ::
    GHC.Base.Applicative (Freer.Free f) =>
    forall a. a -> Freer.Free f a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Freer.Free f)
                   @ a
                   eta :: a ->
                 Freer.Pure @ f @ a eta) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFreefFree ::
    (GHC.Base.Monad (Freer.Free f), GHC.Base.Functor f) =>
    Base.MonadFree f (Freer.Free f)
  DFunId[1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dMonad :: GHC.Base.Monad (Freer.Free f)
                      $dFunctor :: GHC.Base.Functor f.
                  @ f
                  @ (Freer.Free f)
                  $dMonad
                  (Freer.$fMonadFreefFree_$cwrap @ f $dMonad $dFunctor) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $fMonadFreefFree_$cwrap ::
    (GHC.Base.Monad (Freer.Free f), GHC.Base.Functor f) =>
    forall a. f (Freer.Free f a) -> Freer.Free f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   $dMonad :: GHC.Base.Monad (Freer.Free f)
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   a1 :: f (Freer.Free f a) ->
                 Freer.Impure
                   @ f
                   @ a
                   @ (Freer.Free f a)
                   a1
                   (GHC.Base.id @ (Freer.Free f a))) -}
a0eb37a889b29470dd0991ecc3fcca1f
  $w$c>>= ::
    Freer.Free f a -> (a -> Freer.Free f b) -> Freer.Free f b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,C(U)>,
     Inline: [0] -}
78a6d66c90f485d35edca7dd8cf63d08
  $wrun ::
    Freer.Free Base.F a -> GHC.Types.Int -> (# GHC.Types.Int, a #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
a0eb37a889b29470dd0991ecc3fcca1f
  data Free (f :: * -> *) a where
    Pure :: a -> Free f a
    Impure :: (f b) -> (b -> Freer.Free f a) -> Free f a
8daa55c4205e31ea197f874e0e858f51
  fold :: (forall b. f b -> b) -> Freer.Free f a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
b6b4a95c2887dbc898fc42439fb86672
  run :: Freer.Free Base.F a -> GHC.Types.Int -> (GHC.Types.Int, a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: Freer.Free Base.F a w1 :: GHC.Types.Int ->
                 case Freer.$wrun @ a w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
instance GHC.Base.Applicative [Freer.Free]
  = Freer.$fApplicativeFree
instance GHC.Base.Functor [Freer.Free] = Freer.$fFunctorFree
instance GHC.Base.Monad [Freer.Free] = Freer.$fMonadFree
instance Base.MonadFree [., Freer.Free] = Freer.$fMonadFreefFree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

