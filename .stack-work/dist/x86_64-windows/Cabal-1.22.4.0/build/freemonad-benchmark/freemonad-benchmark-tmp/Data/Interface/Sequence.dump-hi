
==================== FINAL INTERFACE ====================
2016-01-04 15:35:10.4961328 UTC

interface main@main:Data.Interface.Sequence 7102
  interface hash: c228c55d6397d576d82ded8e63606ca9
  ABI hash: e396efb16cba94628b88f251a019716f
  export-list hash: 3da55aedc72aad909a3f640f5b2a5d12
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4a6c35880612855361971b1dd17516d9
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Interface.Sequence.Sequence{Data.Interface.Sequence..<| Data.Interface.Sequence..>< Data.Interface.Sequence..|> Data.Interface.Sequence.empty Data.Interface.Sequence.singleton Data.Interface.Sequence.viewl Data.Interface.Sequence.viewr}
  Data.Interface.Sequence.ViewL{Data.Interface.Sequence.:< Data.Interface.Sequence.EmptyL}
  Data.Interface.Sequence.ViewR{Data.Interface.Sequence.:> Data.Interface.Sequence.EmptyR}
module dependencies:
package dependencies: base-4.8.1.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
import  -/  base-4.8.1.0:Control.Applicative a283901553892ce761385d18e455c2ce
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.Monoid bd73caba6e77f9944cb89ef5bec300c6
import  -/  base-4.8.1.0:Data.Traversable 89769555cf5e62f4edd3d085405c2caa
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
aab36e06d13f0d34115f99cffcffc571
  $dm.<| ::
    Data.Interface.Sequence.Sequence s => forall a. a -> s a -> s a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: * -> *)
                   $dSequence :: Data.Interface.Sequence.Sequence s
                   @ a
                   l :: a
                   r :: s a ->
                 Data.Interface.Sequence..><
                   @ s
                   $dSequence
                   @ a
                   (Data.Interface.Sequence.singleton @ s $dSequence @ a l)
                   r) -}
26f56ee85918cdc043bb8fa2dcf2eae6
  $dm.>< ::
    Data.Interface.Sequence.Sequence s => forall a. s a -> s a -> s a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(S)LLL),U(A,A,1*C1(C1(U)),1*C1(U),A,A,1*C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: * -> *)
                   $dSequence :: Data.Interface.Sequence.Sequence s
                   @ a
                   l :: s a
                   r :: s a ->
                 case Data.Interface.Sequence.viewl @ s $dSequence @ a l of wild {
                   Data.Interface.Sequence.EmptyL -> r
                   Data.Interface.Sequence.:< h t
                   -> Data.Interface.Sequence..<|
                        @ s
                        $dSequence
                        @ a
                        h
                        (Data.Interface.Sequence..>< @ s $dSequence @ a t r) }) -}
38c887081f0e2b20babc3399da1ffbc9
  $dm.|> ::
    Data.Interface.Sequence.Sequence s => forall a. s a -> a -> s a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: * -> *)
                   $dSequence :: Data.Interface.Sequence.Sequence s
                   @ a
                   l :: s a
                   r :: a ->
                 Data.Interface.Sequence..><
                   @ s
                   $dSequence
                   @ a
                   l
                   (Data.Interface.Sequence.singleton @ s $dSequence @ a r)) -}
73821db9558e6e6cd341f3c246f84e28
  $dmviewl ::
    Data.Interface.Sequence.Sequence s =>
    forall a. s a -> Data.Interface.Sequence.ViewL s a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LL),U(1*U,A,A,1*C1(U),1*C1(U),1*C1(C1(U)),A)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: * -> *)
                   $dSequence :: Data.Interface.Sequence.Sequence s
                   @ a
                   q :: s a ->
                 case Data.Interface.Sequence.viewr @ s $dSequence @ a q of wild {
                   Data.Interface.Sequence.EmptyR
                   -> Data.Interface.Sequence.EmptyL @ s @ a
                   Data.Interface.Sequence.:> p l
                   -> case Data.Interface.Sequence.viewl
                             @ s
                             $dSequence
                             @ a
                             p of wild1 {
                        Data.Interface.Sequence.EmptyL
                        -> Data.Interface.Sequence.:<
                             @ s
                             @ a
                             l
                             (Data.Interface.Sequence.empty @ s $dSequence @ a)
                        Data.Interface.Sequence.:< h t
                        -> Data.Interface.Sequence.:<
                             @ s
                             @ a
                             h
                             (Data.Interface.Sequence..|> @ s $dSequence @ a t l) } }) -}
a4cff5b0b2bd6b5e128b936b540b035d
  $dmviewr ::
    Data.Interface.Sequence.Sequence s =>
    forall a. s a -> Data.Interface.Sequence.ViewR s a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)LLL),U(1*U,A,A,1*C1(U),1*C1(U),A,1*C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: * -> *)
                   $dSequence :: Data.Interface.Sequence.Sequence s
                   @ a
                   q :: s a ->
                 case Data.Interface.Sequence.viewl @ s $dSequence @ a q of wild {
                   Data.Interface.Sequence.EmptyL
                   -> Data.Interface.Sequence.EmptyR @ s @ a
                   Data.Interface.Sequence.:< h t
                   -> case Data.Interface.Sequence.viewr
                             @ s
                             $dSequence
                             @ a
                             t of wild1 {
                        Data.Interface.Sequence.EmptyR
                        -> Data.Interface.Sequence.:>
                             @ s
                             @ a
                             (Data.Interface.Sequence.empty @ s $dSequence @ a)
                             h
                        Data.Interface.Sequence.:> p l
                        -> Data.Interface.Sequence.:>
                             @ s
                             @ a
                             (Data.Interface.Sequence..<| @ s $dSequence @ a h p)
                             l } }) -}
5ee504e09e56f26139db9b484571ccdc
  class Sequence (s :: * -> *) where
    empty :: s a
    singleton :: a -> s a
    (.><) {- Has default method -} :: s a -> s a -> s a
    viewl {- Has default method -} ::
      s a -> Data.Interface.Sequence.ViewL s a
    viewr {- Has default method -} ::
      s a -> Data.Interface.Sequence.ViewR s a
    (.|>) {- Has default method -} :: s a -> a -> s a
    (.<|) {- Has default method -} :: a -> s a -> s a
d18af3082672d34e1441672468965a29
  type role ViewL representational nominal
  data ViewL (s :: * -> *) a where
    EmptyL :: ViewL s a
    (:<) :: a -> (s a) -> ViewL s a
2d0d55ba0edd0ce43eeb1feee8c332ab
  type role ViewR representational nominal
  data ViewR (s :: * -> *) a where
    EmptyR :: ViewR s a
    (:>) :: (s a) -> a -> ViewR s a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

