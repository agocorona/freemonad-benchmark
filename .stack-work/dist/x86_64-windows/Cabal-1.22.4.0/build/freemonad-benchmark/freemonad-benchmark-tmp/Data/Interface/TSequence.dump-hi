
==================== FINAL INTERFACE ====================
2016-01-04 15:35:10.9301832 UTC

interface main@main:Data.Interface.TSequence [orphan module] 7102
  interface hash: 1e7eecf89e326587decc34e88284dbe3
  ABI hash: e7c1c4592f1a02ccf97efe09e6a07e60
  export-list hash: 30011f52b7228743e59eb112c86ccb83
  orphan hash: 0fc658c40cb1a55780819a7b13ac0bf6
  flag hash: 639525117a1c60085743cfadae3da060
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Interface.TSequence.TSequence{Data.Interface.TSequence.<| Data.Interface.TSequence.>< Data.Interface.TSequence.tempty Data.Interface.TSequence.tsingleton Data.Interface.TSequence.tviewl Data.Interface.TSequence.tviewr Data.Interface.TSequence.|>}
  Data.Interface.TSequence.TViewL{Data.Interface.TSequence.:| Data.Interface.TSequence.TEmptyL}
  Data.Interface.TSequence.TViewR{Data.Interface.TSequence.:|< Data.Interface.TSequence.TEmptyR}
module dependencies: Data.Interface.Sequence
package dependencies: base-4.8.1.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
import  -/  base-4.8.1.0:Control.Category c95205851203e5178b69a55d83625b5a
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  Data.Interface.Sequence e396efb16cba94628b88f251a019716f
  exports: 3da55aedc72aad909a3f640f5b2a5d12
fixities infix 5 ><, infixl 5 |>, infixr 5 <|
4fec1a83ff24a58b44d59b2e6ed952c3
  $dm<| ::
    Data.Interface.TSequence.TSequence s =>
    forall (c :: * -> * -> *) x y z. c x y -> s c y z -> s c x z
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ (c :: * -> * -> *)
                   @ x
                   @ y
                   @ z
                   l :: c x y
                   r :: s c y z ->
                 Data.Interface.TSequence.><
                   @ s
                   $dTSequence
                   @ c
                   @ x
                   @ y
                   @ z
                   (Data.Interface.TSequence.tsingleton @ s $dTSequence @ c @ x @ y l)
                   r) -}
436ab3fb6f784b3adbb8cad6ec14a3db
  $dm>< ::
    Data.Interface.TSequence.TSequence s =>
    forall (c :: * -> * -> *) x y z. s c x y -> s c y z -> s c x z
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(S)LLL),U(A,A,1*C1(C1(U)),1*C1(U),A,A,1*C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ (c :: * -> * -> *)
                   @ x
                   @ y
                   @ z
                   l :: s c x y
                   r :: s c y z ->
                 case Data.Interface.TSequence.tviewl
                        @ s
                        $dTSequence
                        @ c
                        @ x
                        @ y
                        l of wild {
                   Data.Interface.TSequence.TEmptyL dt
                   -> r `cast` (<s c>_R (Sym dt) <z>_N)
                   Data.Interface.TSequence.:| y1 h t
                   -> Data.Interface.TSequence.<|
                        @ s
                        $dTSequence
                        @ c
                        @ x
                        @ y1
                        @ z
                        h
                        (Data.Interface.TSequence.><
                           @ s
                           $dTSequence
                           @ c
                           @ y1
                           @ y
                           @ z
                           t
                           r) }) -}
60c9e8fa8798b23a7b579377bcc1a27c
  $dmtviewl ::
    Data.Interface.TSequence.TSequence s =>
    forall (c :: * -> * -> *) x y.
    s c x y -> Data.Interface.TSequence.TViewL s c x y
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LL),U(1*U,A,A,1*C1(U),1*C1(U),1*C1(C1(U)),A)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ (c :: * -> * -> *)
                   @ x
                   @ y
                   q :: s c x y ->
                 case Data.Interface.TSequence.tviewr
                        @ s
                        $dTSequence
                        @ c
                        @ x
                        @ y
                        q of wild {
                   Data.Interface.TSequence.TEmptyR dt
                   -> (Data.Interface.TSequence.$WTEmptyL @ s @ c @ x)
                        `cast`
                      (Data.Interface.TSequence.TViewL <s>_R <c>_N <x>_N dt)_R
                   Data.Interface.TSequence.:|< y1 p l
                   -> case Data.Interface.TSequence.tviewl
                             @ s
                             $dTSequence
                             @ c
                             @ x
                             @ y1
                             p of wild1 {
                        Data.Interface.TSequence.TEmptyL dt
                        -> Data.Interface.TSequence.:|
                             @ s
                             @ c
                             @ x
                             @ y
                             @ y
                             l `cast` (<c>_R (Sym dt) <y>_N)
                             (Data.Interface.TSequence.tempty @ s $dTSequence @ c @ y)
                        Data.Interface.TSequence.:| y2 h t
                        -> Data.Interface.TSequence.:|
                             @ s
                             @ c
                             @ x
                             @ y
                             @ y2
                             h
                             (Data.Interface.TSequence.|>
                                @ s
                                $dTSequence
                                @ c
                                @ y2
                                @ y1
                                @ y
                                t
                                l) } }) -}
55b8874aa710064c9f597eb234c7fd87
  $dmtviewr ::
    Data.Interface.TSequence.TSequence s =>
    forall (c :: * -> * -> *) x y.
    s c x y -> Data.Interface.TSequence.TViewR s c x y
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)LLL),U(1*U,A,A,1*C1(U),1*C1(U),A,1*C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ (c :: * -> * -> *)
                   @ x
                   @ y
                   q :: s c x y ->
                 case Data.Interface.TSequence.tviewl
                        @ s
                        $dTSequence
                        @ c
                        @ x
                        @ y
                        q of wild {
                   Data.Interface.TSequence.TEmptyL dt
                   -> (Data.Interface.TSequence.$WTEmptyR @ s @ c @ x)
                        `cast`
                      (Data.Interface.TSequence.TViewR <s>_R <c>_N <x>_N dt)_R
                   Data.Interface.TSequence.:| y1 h t
                   -> case Data.Interface.TSequence.tviewr
                             @ s
                             $dTSequence
                             @ c
                             @ y1
                             @ y
                             t of wild1 {
                        Data.Interface.TSequence.TEmptyR dt
                        -> Data.Interface.TSequence.:|<
                             @ s
                             @ c
                             @ x
                             @ y
                             @ x
                             (Data.Interface.TSequence.tempty @ s $dTSequence @ c @ x)
                             h `cast` (<c x>_R dt)
                        Data.Interface.TSequence.:|< y2 p l
                        -> Data.Interface.TSequence.:|<
                             @ s
                             @ c
                             @ x
                             @ y
                             @ y2
                             (Data.Interface.TSequence.<| @ s $dTSequence @ c @ x @ y1 @ y2 h p)
                             l } }) -}
660131bde6d447a961070b10c848b5ca
  $dm|> ::
    Data.Interface.TSequence.TSequence s =>
    forall (c :: * -> * -> *) x y z. s c x y -> c y z -> s c x z
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ (c :: * -> * -> *)
                   @ x
                   @ y
                   @ z
                   l :: s c x y
                   r :: c y z ->
                 Data.Interface.TSequence.><
                   @ s
                   $dTSequence
                   @ c
                   @ x
                   @ y
                   @ z
                   l
                   (Data.Interface.TSequence.tsingleton
                      @ s
                      $dTSequence
                      @ c
                      @ y
                      @ z
                      r)) -}
91e430ef72c2342b216ecde9fc6fe431
  $fCategory*s ::
    Data.Interface.TSequence.TSequence s =>
    Control.Category.Category (s c)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U,A,C(C1(U)),A,A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (s :: (* -> * -> *) -> * -> * -> *)
                      @ (c :: * -> * -> *)
                      $dTSequence :: Data.Interface.TSequence.TSequence s.
                  @ *
                  @ (s c)
                  (Data.Interface.TSequence.$fCategory*s_$cid @ s @ c $dTSequence)
                  (Data.Interface.TSequence.$fCategory*s_$c. @ s @ c $dTSequence) -}
4ce46db7b33dc335b36ce2e01247ec02
  $fCategory*s_$c. ::
    Data.Interface.TSequence.TSequence s =>
    forall b c1 a. s c b c1 -> s c a b -> s c a c1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   @ (c :: * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ b
                   @ c1
                   @ a
                   eta :: s c b c1
                   eta1 :: s c a b ->
                 Data.Interface.TSequence.><
                   @ s
                   $dTSequence
                   @ c
                   @ a
                   @ b
                   @ c1
                   eta1
                   eta) -}
8b30373ddd5f8d49baaa15bff0c3ee08
  $fCategory*s_$cid ::
    Data.Interface.TSequence.TSequence s => forall a. s c a a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, True)
                (\ @ (s :: (* -> * -> *) -> * -> * -> *)
                   @ (c :: * -> * -> *)
                   $dTSequence :: Data.Interface.TSequence.TSequence s
                   @ a ->
                 Data.Interface.TSequence.tempty @ s $dTSequence @ c @ a) -}
700ffae603f8ab46db12fb2efd22dad5
  class TSequence (s :: (* -> * -> *) -> * -> * -> *) where
    tempty :: s c x x
    tsingleton :: c x y -> s c x y
    (><) {- Has default method -} :: s c x y -> s c y z -> s c x z
    tviewl {- Has default method -} ::
      s c x y -> Data.Interface.TSequence.TViewL s c x y
    tviewr {- Has default method -} ::
      s c x y -> Data.Interface.TSequence.TViewR s c x y
    (|>) {- Has default method -} :: s c x y -> c y z -> s c x z
    (<|) {- Has default method -} :: c x y -> s c y z -> s c x z
ff5b14e3d77211830ceb9f0bae081134
  type role TViewL representational nominal nominal nominal
  data TViewL (s :: (* -> * -> *) -> * -> * -> *)
              (c :: * -> * -> *)
              x
              y where
    TEmptyL :: TViewL s c y y
    (:|) :: (c x y1) -> (s c y1 y) -> TViewL s c x y
10ecbc5a40238fb5262972f6fea31906
  type role TViewR representational nominal nominal nominal
  data TViewR (s :: (* -> * -> *) -> * -> * -> *)
              (c :: * -> * -> *)
              x
              y where
    TEmptyR :: TViewR s c y y
    (:|<) :: (s c x y1) -> (c y1 y) -> TViewR s c x y
instance Control.Category.Category [*, .]
  = Data.Interface.TSequence.$fCategory*s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

