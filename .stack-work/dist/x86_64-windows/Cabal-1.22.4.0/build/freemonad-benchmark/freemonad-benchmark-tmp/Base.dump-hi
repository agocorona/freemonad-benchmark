
==================== FINAL INTERFACE ====================
2016-01-04 15:35:13.2644642 UTC

interface main@main:Base 7102
  interface hash: 1432d57ec5c12a6e70bf0c3f1fb3d9a8
  ABI hash: 4539c1b83b5f5c3bc3a6d6f65d743fb2
  export-list hash: 8763dd5bae4f40ca274cc839ac61fcf9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d07d3cd7e2604c774f785a4a0dca6ee8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Base.get
  Base.put
  Base.F{Base.F Base.unF}
  Base.MonadFree{Base.wrap}
module dependencies:
package dependencies: Win32-2.3.1.0@Win32_JH0ECVJdFmmG0JOvttvGqi
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
                      lifted-base-0.2.3.6@lifte_K3cQFA6mRg85rpDaA9numU
                      mmorph-1.0.4@mmorp_8dNpUU8QFPe77rrwKAb20b
                      monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo
                      time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      transformers-base-0.4.4@trans_88TAFm21vtn2NrYUppy50c
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming.Prelude
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Format.Parse
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b:Control.Monad.Trans.Control
                         resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS:Control.Monad.Trans.Resource.Internal
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming 6ae0afab408880e229212a0832df022e
import  -/  streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming.Internal 4963dab9d6f5965042cc7c3b3f5762dd
7cbec1f8f3194174f75be33e5b893b9f
  $c>>= :: Base.F a -> (a -> Base.F b) -> Base.F b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(C(U(U,U)))><L,C(U(1*C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a3 @ b w :: Base.F a3 w1 :: a3 -> Base.F b ->
                 case w of ww { Base.F ww1 ->
                 Base.F
                   @ b
                   (\ s :: GHC.Types.Int ->
                    let {
                      ds :: (GHC.Types.Int, a3) = ww1 s
                    } in
                    case w1
                           (case ds of wild { (,) s' a4 -> a4 }) of wild { Base.F ds1 ->
                    ds1 (case ds of wild1 { (,) s' a4 -> s' }) }) }) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fApplicativeF :: GHC.Base.Applicative Base.F
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Base.F
                  Base.$fFunctorF
                  (\ @ a3 -> GHC.Err.undefined @ (a3 -> Base.F a3))
                  (\ @ a3 @ b ->
                   GHC.Err.undefined @ (Base.F (a3 -> b) -> Base.F a3 -> Base.F b))
                  Base.$fApplicativeF_$s$dm*>
                  Base.$fApplicativeF_$s$dm<* -}
7cbec1f8f3194174f75be33e5b893b9f
  $fApplicativeF_$s$dm*> :: Base.F a -> Base.F b -> Base.F b
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (-1, True, False)
                (\ @ a3 @ b eta :: Base.F a3 eta1 :: Base.F b ->
                 case GHC.Err.undefined ret_ty (Base.F b) of {}) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fApplicativeF_$s$dm<* :: Base.F a -> Base.F b -> Base.F a
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (-1, True, False)
                (\ @ a3 @ b eta :: Base.F a3 eta1 :: Base.F b ->
                 Base.$fApplicativeF_$sliftA2
                   @ a3
                   @ b
                   @ a3
                   (GHC.Base.const @ a3 @ b)
                   eta
                   eta1) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fApplicativeF_$sliftA2 ::
    (a -> b -> c) -> Base.F a -> Base.F b -> Base.F c
  {- Arity: 3, Strictness: <B,A><B,A><B,A>b,
     Unfolding: InlineRule (3, True, False)
                (\ @ a3
                   @ b
                   @ c
                   eta :: a3 -> b -> c
                   eta1 :: Base.F a3
                   eta2 :: Base.F b ->
                 case GHC.Err.undefined ret_ty (Base.F c) of {}) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fFunctorF :: GHC.Base.Functor Base.F
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Base.F Base.$fFunctorF_$cfmap Base.$fFunctorF_$c<$ -}
7cbec1f8f3194174f75be33e5b893b9f
  $fFunctorF_$c<$ :: a -> Base.F b -> Base.F a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(C(U(U,A)))>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a3 @ b eta :: a3 ds :: Base.F b ->
                 case ds of wild { Base.F a4 ->
                 Base.F
                   @ a3
                   (\ b5 :: GHC.Types.Int ->
                    case a4 b5 of wild1 { (,) a5 a6 -> (a5, eta) }) }) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fFunctorF_$cfmap :: (a -> b) -> Base.F a -> Base.F b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(C(U(U,U)))>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a3 @ b f :: a3 -> b ds :: Base.F a3 ->
                 case ds of wild { Base.F a4 ->
                 Base.F
                   @ b
                   (\ b5 :: GHC.Types.Int ->
                    case a4 b5 of wild1 { (,) a5 a6 -> (a5, f a6) }) }) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fMonadF :: GHC.Base.Monad Base.F
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Base.F
                  Base.$fApplicativeF
                  Base.$c>>=
                  Base.$fMonadF_$c>>
                  Base.$fMonadF_$creturn
                  Base.$fMonadF_$s$dmfail -}
7cbec1f8f3194174f75be33e5b893b9f
  $fMonadF_$c>> :: Base.F a -> Base.F b -> Base.F b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a3 @ b m1 :: Base.F a3 k :: Base.F b ->
                 Base.$c>>= @ a3 @ b m1 (\ ds :: a3 -> k)) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fMonadF_$creturn :: a -> Base.F a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a3 a4 :: a3 ->
                 Base.F @ a3 (\ n :: GHC.Types.Int -> (n, a4))) -}
7cbec1f8f3194174f75be33e5b893b9f
  $fMonadF_$s$dmfail :: GHC.Base.String -> Base.F a
  {- Arity: 1, Strictness: <B,U>b,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a3 eta :: [GHC.Types.Char] ->
                 GHC.Err.error @ (Base.F a3) eta) -}
214a069f1b90a7dfdbb158c26b94063c
  $fMonadFreefStream ::
    (GHC.Base.Monad (Streaming.Internal.Stream f m),
     GHC.Base.Functor f, GHC.Base.Monad m) =>
    Base.MonadFree f (Streaming.Internal.Stream f m)
  DFunId[1]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><L,A>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      @ (m :: * -> *)
                      $dMonad :: GHC.Base.Monad (Streaming.Internal.Stream f m)
                      $dFunctor :: GHC.Base.Functor f
                      $dMonad1 :: GHC.Base.Monad m.
                  @ f
                  @ (Streaming.Internal.Stream f m)
                  $dMonad
                  (Base.$fMonadFreefStream_$cwrap
                     @ f
                     @ m
                     $dMonad
                     $dFunctor
                     $dMonad1) -}
d830d036c9dc88aaf1bcaf1c695a6024
  $fMonadFreefStream_$cwrap ::
    (GHC.Base.Monad (Streaming.Internal.Stream f m),
     GHC.Base.Functor f, GHC.Base.Monad m) =>
    forall a.
    f (Streaming.Internal.Stream f m a)
    -> Streaming.Internal.Stream f m a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad (Streaming.Internal.Stream f m)
                   $dFunctor :: GHC.Base.Functor f
                   $dMonad1 :: GHC.Base.Monad m
                   @ a3
                   eta :: f (Streaming.Internal.Stream f m a3) ->
                 Streaming.Internal.$WStep @ f @ m @ a3 eta) -}
7cbec1f8f3194174f75be33e5b893b9f
  data F a = F {unF :: GHC.Types.Int -> (GHC.Types.Int, a)}
214a069f1b90a7dfdbb158c26b94063c
  class GHC.Base.Monad m =>
        MonadFree (f :: * -> *) (m :: * -> *) | m -> f where
    wrap :: f (m a) -> m a
edd46a3bf87ed25d7f60115f6a119b71
  get :: Base.MonadFree Base.F free => free GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LC(S)),U(1*U,1*C1(U))>,
     Unfolding: (\ @ (free :: * -> *)
                   $dMonadFree :: Base.MonadFree Base.F free ->
                 let {
                   $dMonad :: GHC.Base.Monad free
                   = Base.$p1MonadFree @ Base.F @ free $dMonadFree
                 } in
                 Base.wrap
                   @ Base.F
                   @ free
                   $dMonadFree
                   @ GHC.Types.Int
                   (Base.F
                      @ (free GHC.Types.Int)
                      (\ s :: GHC.Types.Int ->
                       (s, GHC.Base.return @ free $dMonad @ GHC.Types.Int s)))) -}
6f9db9c5bb49679c383a52e34ba24ad8
  put :: Base.MonadFree Base.F free => GHC.Types.Int -> free ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)),U(1*U(A,A,A,1*C1(U),A),1*C1(U))><L,U>,
     Unfolding: (\ @ (free :: * -> *)
                   $dMonadFree :: Base.MonadFree Base.F free
                   eta :: GHC.Types.Int ->
                 let {
                   a3 :: free ()
                   = GHC.Base.return
                       @ free
                       (Base.$p1MonadFree @ Base.F @ free $dMonadFree)
                       @ ()
                       GHC.Tuple.()
                 } in
                 let {
                   lvl :: (GHC.Types.Int, free ()) {- Strictness: m -} = (eta, a3)
                 } in
                 Base.wrap
                   @ Base.F
                   @ free
                   $dMonadFree
                   @ ()
                   (Base.F @ (free ()) (\ ds :: GHC.Types.Int -> lvl))) -}
644f08ccbaffbc1cadd53660d2c7f06d
  unF :: Base.F a -> GHC.Types.Int -> (GHC.Types.Int, a)
  RecSel Base.F
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a3 ds :: Base.F a3 ->
                 case ds of wild { Base.F ds1 -> ds1 }) -}
instance GHC.Base.Applicative [Base.F] = Base.$fApplicativeF
instance GHC.Base.Functor [Base.F] = Base.$fFunctorF
instance GHC.Base.Monad [Base.F] = Base.$fMonadF
instance Base.MonadFree [., Streaming.Internal.Stream]
  = Base.$fMonadFreefStream
"SPEC/Base $dm*> @ F" [ALWAYS] forall $dApplicative :: GHC.Base.Applicative
                                                         Base.F
  GHC.Base.$dm*> @ Base.F $dApplicative = Base.$fApplicativeF_$s$dm*>
"SPEC/Base $dm<* @ F" [ALWAYS] forall $dApplicative :: GHC.Base.Applicative
                                                         Base.F
  GHC.Base.$dm<* @ Base.F $dApplicative = Base.$fApplicativeF_$s$dm<*
"SPEC/Base $dm>> @ F" [ALWAYS] forall $dMonad :: GHC.Base.Monad
                                                   Base.F
  GHC.Base.$dm>> @ Base.F $dMonad
  = \ @ a3 @ b m1 :: Base.F a3 k :: Base.F b ->
    Base.$c>>= @ a3 @ b m1 (\ ds :: a3 -> k)
"SPEC/Base $dmfail @ F" [ALWAYS] forall $dMonad :: GHC.Base.Monad
                                                     Base.F
  GHC.Base.$dmfail @ Base.F $dMonad = Base.$fMonadF_$s$dmfail
"SPEC/Base liftA2 _ _ _ @ F" [ALWAYS] forall @ a3
                                             @ b
                                             @ c
                                             $dApplicative :: GHC.Base.Applicative Base.F
  GHC.Base.liftA2 @ a3 @ b @ c @ Base.F $dApplicative
  = Base.$fApplicativeF_$sliftA2 @ a3 @ b @ c
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

