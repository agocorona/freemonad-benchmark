
==================== FINAL INTERFACE ====================
2016-01-04 15:50:41.5558136 UTC

interface main@main:Codensity 7102
  interface hash: bddec207fdbe8e47da21200ffd1028fa
  ABI hash: 998e470cee8025356c5f3bf0764234fa
  export-list hash: 6755b6e277a176755fe3c7d75b89e6fa
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 3c94a6bf0aae245c33f077efd5ccc103
  sig of: Nothing
  used TH splices: False
  where
exports:
  Codensity.fromCodensity
  Codensity.run
  Codensity.toCodensity
  Codensity.Codensity{Codensity.Codensity Codensity.runCodensity}
module dependencies: Base Free
package dependencies: Win32-2.3.1.0@Win32_JH0ECVJdFmmG0JOvttvGqi
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
                      lifted-base-0.2.3.6@lifte_K3cQFA6mRg85rpDaA9numU
                      mmorph-1.0.4@mmorp_8dNpUU8QFPe77rrwKAb20b
                      monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo
                      time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      transformers-base-0.4.4@trans_88TAFm21vtn2NrYUppy50c
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         streaming-0.1.4.0@strea_FSz849cBl1PCe6X22prWwo:Streaming.Prelude
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.Format.Parse
         time-1.5.0.1@time_ECG3PhVYxEUEM046TXoOWk:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         monad-control-1.0.0.4@monad_3XCDr1mqlERGZgaxuwJF6b:Control.Monad.Trans.Control
                         resourcet-1.1.6@resou_Ic1TzDDmqYbFNHpzRsDmfS:Control.Monad.Trans.Resource.Internal
import  -/  base-4.8.1.0:Control.Applicative a283901553892ce761385d18e455c2ce
import  -/  base-4.8.1.0:Control.Monad dfea142d91349c4861427789d50d5b80
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  Base 4539c1b83b5f5c3bc3a6d6f65d743fb2
  exports: 8763dd5bae4f40ca274cc839ac61fcf9
  F 7cbec1f8f3194174f75be33e5b893b9f
  MonadFree 214a069f1b90a7dfdbb158c26b94063c
  wrap 934c5269797907e84f278b415b88a6c3
import  -/  Free 069f43e8af79f31a76118780d3291a01
  exports: edaba532e6f5b030b282aaf38146d7bb
  Free 53cc26b8bb4ac6b4bc91cff9e377c042
  run 6f7ff988d41a671834135f8067707010
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    GHC.Base.Applicative (Codensity.Codensity f)
  DFunId[1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dFunctor :: GHC.Base.Functor (Codensity.Codensity f).
                  @ (Codensity.Codensity f)
                  $dFunctor
                  (Codensity.$fApplicativeCodensity_$cpure @ f $dFunctor)
                  (Codensity.$fApplicativeCodensity_$c<*> @ f $dFunctor)
                  (Codensity.$fApplicativeCodensity_$c*> @ f $dFunctor)
                  (Codensity.$fApplicativeCodensity_$c<* @ f $dFunctor) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity1 ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f (a -> b)
    -> Codensity.Codensity f a -> forall b1. (b -> f b1) -> f b1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(S),1*C1(U)><L,C(U)><L,C(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Codensity.Codensity f)
                   @ a
                   @ b
                   m1 :: Codensity.Codensity f (a -> b)
                   m2 :: Codensity.Codensity f a
                   @ b1
                   eta :: b -> f b1 ->
                 m1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <a -> b>_R)
                   @ b1
                   (\ a1 :: a -> b ->
                    m2 `cast` (Codensity.NTCo:Codensity[0] <f>_R <a>_R)
                      @ b1
                      (\ a2 :: a -> eta (a1 a2)))) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity2 ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a. a -> forall b. (a -> f b) -> f b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Codensity.Codensity f)
                   @ a
                   a1 :: a
                   @ b
                   k :: a -> f b ->
                 k a1) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity_$c*> ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f a
    -> Codensity.Codensity f b -> Codensity.Codensity f b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(U)))><L,U><L,C(U)>,
     Unfolding: (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Codensity.Codensity f)
                   @ a
                   @ b
                   eta :: Codensity.Codensity f a
                   eta1 :: Codensity.Codensity f b ->
                 let {
                   m1 :: Codensity.Codensity f (b -> b)
                   = GHC.Base.<$
                       @ (Codensity.Codensity f)
                       $dFunctor
                       @ (b -> b)
                       @ a
                       (GHC.Base.id @ b)
                       eta
                 } in
                 (\ @ b1 eta2 :: b -> f b1 ->
                  m1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <b -> b>_R)
                    @ b1
                    (\ a1 :: b -> b ->
                     eta1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <b>_R)
                       @ b1
                       (\ a2 :: b -> eta2 (a1 a2))))
                   `cast`
                 (Sym (Codensity.NTCo:Codensity[0] <f>_R <b>_R))) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity_$c<* ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f a
    -> Codensity.Codensity f b -> Codensity.Codensity f a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,C(U)>,
     Unfolding: (\ @ (f :: * -> *)
                   $dFunctor :: GHC.Base.Functor (Codensity.Codensity f)
                   @ a
                   @ b
                   eta :: Codensity.Codensity f a
                   eta1 :: Codensity.Codensity f b ->
                 let {
                   m1 :: Codensity.Codensity f (b -> a)
                   = GHC.Base.fmap
                       @ (Codensity.Codensity f)
                       $dFunctor
                       @ a
                       @ (b -> a)
                       (GHC.Base.const @ a @ b)
                       eta
                 } in
                 (\ @ b1 eta2 :: a -> f b1 ->
                  m1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <b -> a>_R)
                    @ b1
                    (\ a1 :: b -> a ->
                     eta1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <b>_R)
                       @ b1
                       (\ a2 :: b -> eta2 (a1 a2))))
                   `cast`
                 (Sym (Codensity.NTCo:Codensity[0] <f>_R <a>_R))) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity_$c<*> ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f (a -> b)
    -> Codensity.Codensity f a -> Codensity.Codensity f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(S),1*C1(U)><L,C(U)><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fApplicativeCodensity1
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Functor (Codensity.Codensity f)>_R
                 ->_R forall a b.
                      <Codensity.Codensity f (a -> b)>_R
                      ->_R <Codensity.Codensity f a>_R
                      ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <b>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fApplicativeCodensity_$cpure ::
    GHC.Base.Functor (Codensity.Codensity f) =>
    forall a. a -> Codensity.Codensity f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fApplicativeCodensity2
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Functor (Codensity.Codensity f)>_R
                 ->_R forall a.
                      <a>_R ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <a>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fFunctorCodensity :: GHC.Base.Functor (Codensity.Codensity f)
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *).
                  @ (Codensity.Codensity f)
                  (Codensity.$fFunctorCodensity_$cfmap @ f)
                  (Codensity.$fFunctorCodensity_$c<$ @ f) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fFunctorCodensity1 ::
    a -> Codensity.Codensity f b -> forall b1. (a -> f b1) -> f b1
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   eta :: a
                   eta1 :: Codensity.Codensity f b
                   @ b1
                   eta2 :: a -> f b1 ->
                 eta1 `cast` (Codensity.NTCo:Codensity[0] <f>_R <b>_R)
                   @ b1
                   (\ x :: b -> eta2 eta)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fFunctorCodensity2 ::
    (a -> b)
    -> Codensity.Codensity f a -> forall b1. (b -> f b1) -> f b1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><C(S),1*C1(U)><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   f1 :: a -> b
                   m :: Codensity.Codensity f a
                   @ b1
                   k :: b -> f b1 ->
                 m `cast` (Codensity.NTCo:Codensity[0] <f>_R <a>_R)
                   @ b1
                   (GHC.Base.. @ b @ (f b1) @ a k f1)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fFunctorCodensity_$c<$ ::
    a -> Codensity.Codensity f b -> Codensity.Codensity f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fFunctorCodensity1
                  `cast`
                (forall (f :: * -> *) a b.
                 <a>_R
                 ->_R <Codensity.Codensity f b>_R
                 ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <a>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fFunctorCodensity_$cfmap ::
    (a -> b) -> Codensity.Codensity f a -> Codensity.Codensity f b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(U)><C(S),1*C1(U)><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fFunctorCodensity2
                  `cast`
                (forall (f :: * -> *) a b.
                 <a -> b>_R
                 ->_R <Codensity.Codensity f a>_R
                 ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <b>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    GHC.Base.Monad (Codensity.Codensity f)
  DFunId[1]
  {- Arity: 1, Strictness: <L,U>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dApplicative :: GHC.Base.Applicative (Codensity.Codensity f).
                  @ (Codensity.Codensity f)
                  $dApplicative
                  (Codensity.$fMonadCodensity_$c>>= @ f $dApplicative)
                  (Codensity.$fMonadCodensity_$c>> @ f $dApplicative)
                  (Codensity.$fMonadCodensity_$creturn @ f $dApplicative)
                  (Codensity.$fMonadCodensity_$cfail @ f $dApplicative) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity1 ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a. a -> forall b. (a -> f b) -> f b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Codensity.Codensity f)
                   @ a
                   a1 :: a
                   @ b
                   k :: a -> f b ->
                 k a1) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity2 ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f a
    -> (a -> Codensity.Codensity f b) -> forall b1. (b -> f b1) -> f b1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(S),1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Codensity.Codensity f)
                   @ a
                   @ b
                   c :: Codensity.Codensity f a
                   f1 :: a -> Codensity.Codensity f b
                   @ b1
                   k :: b -> f b1 ->
                 c `cast` (Codensity.NTCo:Codensity[0] <f>_R <a>_R)
                   @ b1
                   (\ a1 :: a ->
                    (f1 a1) `cast` (Codensity.NTCo:Codensity[0] <f>_R <b>_R)
                      @ b1
                      k)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity_$c>> ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f a
    -> Codensity.Codensity f b -> Codensity.Codensity f b
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Codensity.Codensity f)
                   @ a
                   @ b
                   m1 :: Codensity.Codensity f a
                   k :: Codensity.Codensity f b
                   @ b1
                   eta :: b -> f b1 ->
                 (Codensity.$fMonadCodensity_$c>>=
                    @ f
                    $dApplicative
                    @ a
                    @ b
                    m1
                    (\ ds :: a -> k))
                   `cast`
                 (Codensity.NTCo:Codensity[0] <f>_R <b>_R)
                   @ b1
                   eta)
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Applicative (Codensity.Codensity f)>_R
                 ->_R forall a b.
                      <Codensity.Codensity f a>_R
                      ->_R <Codensity.Codensity f b>_R
                      ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <b>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity_$c>>= ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a b.
    Codensity.Codensity f a
    -> (a -> Codensity.Codensity f b) -> Codensity.Codensity f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><C(S),1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fMonadCodensity2
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Applicative (Codensity.Codensity f)>_R
                 ->_R forall a b.
                      <Codensity.Codensity f a>_R
                      ->_R <a -> Codensity.Codensity f b>_R
                      ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <b>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity_$cfail ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a. GHC.Base.String -> Codensity.Codensity f a
  {- Arity: 2, Strictness: <B,A><B,U>b,
     Unfolding: InlineRule (2, True, True)
                (\ @ (f :: * -> *)
                   $dApplicative :: GHC.Base.Applicative (Codensity.Codensity f)
                   @ a
                   eta :: [GHC.Types.Char] ->
                 GHC.Err.error @ (Codensity.Codensity f a) eta) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadCodensity_$creturn ::
    GHC.Base.Applicative (Codensity.Codensity f) =>
    forall a. a -> Codensity.Codensity f a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fMonadCodensity1
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Applicative (Codensity.Codensity f)>_R
                 ->_R forall a.
                      <a>_R ->_R Sym (Codensity.NTCo:Codensity[0] <f>_R <a>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadFreefCodensity ::
    (GHC.Base.Monad (Codensity.Codensity (Free.Free f)),
     GHC.Base.Functor f) =>
    Base.MonadFree f (Codensity.Codensity (Free.Free f))
  DFunId[1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (f :: * -> *)
                      $dMonad :: GHC.Base.Monad (Codensity.Codensity (Free.Free f))
                      $dFunctor :: GHC.Base.Functor f.
                  @ f
                  @ (Codensity.Codensity (Free.Free f))
                  $dMonad
                  (Codensity.$fMonadFreefCodensity_$cwrap @ f $dMonad $dFunctor) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadFreefCodensity1 ::
    (GHC.Base.Monad (Codensity.Codensity (Free.Free f)),
     GHC.Base.Functor f) =>
    forall a.
    f (Codensity.Codensity (Free.Free f) a)
    -> forall b. (a -> Free.Free f b) -> Free.Free f b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,1*U(1*C1(C1(U)),A)><L,U><L,U>m2,
     Unfolding: InlineRule (4, True, False)
                (\ @ (f :: * -> *)
                   $dMonad :: GHC.Base.Monad (Codensity.Codensity (Free.Free f))
                   $dFunctor :: GHC.Base.Functor f
                   @ a
                   t :: f (Codensity.Codensity (Free.Free f) a)
                   @ b
                   h :: a -> Free.Free f b ->
                 Free.Free
                   @ f
                   @ b
                   (GHC.Base.fmap
                      @ f
                      $dFunctor
                      @ (Codensity.Codensity (Free.Free f) a)
                      @ (Free.Free f b)
                      (\ ds :: Codensity.Codensity (Free.Free f) a ->
                       ds `cast` (Codensity.NTCo:Codensity[0] <Free.Free f>_R <a>_R)
                         @ b
                         h)
                      t)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  $fMonadFreefCodensity_$cwrap ::
    (GHC.Base.Monad (Codensity.Codensity (Free.Free f)),
     GHC.Base.Functor f) =>
    forall a.
    f (Codensity.Codensity (Free.Free f) a)
    -> Codensity.Codensity (Free.Free f) a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,1*U(1*C1(C1(U)),A)><L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Codensity.$fMonadFreefCodensity1
                  `cast`
                (forall (f :: * -> *).
                 <GHC.Base.Monad (Codensity.Codensity (Free.Free f))>_R
                 ->_R <GHC.Base.Functor f>_R
                 ->_R forall a.
                      <f (Codensity.Codensity (Free.Free f) a)>_R
                      ->_R Sym (Codensity.NTCo:Codensity[0] <Free.Free f>_R <a>_R)) -}
d0a1b97be5e43fb7cebf1fc0bd6b9af6
  newtype Codensity (f :: * -> *) a
    = Codensity {runCodensity :: forall b. (a -> f b) -> f b}
24fe3d7ae1bdc02bd4bd605d966e46dc
  fromCodensity :: GHC.Base.Monad m => Codensity.Codensity m a -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*U,A)><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   $dMonad :: GHC.Base.Monad m
                   c :: Codensity.Codensity m a ->
                 c `cast` (Codensity.NTCo:Codensity[0] <m>_R <a>_R)
                   @ a
                   (GHC.Base.return @ m $dMonad @ a)) -}
32cf2fca7fadf5b2252dfa1bff517a63
  run ::
    Codensity.Codensity (Free.Free Base.F) a
    -> GHC.Types.Int -> (GHC.Types.Int, a)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*C1(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a x :: Codensity.Codensity (Free.Free Base.F) a ->
                 let {
                   w :: Free.Free Base.F a
                   = x `cast` (Codensity.NTCo:Codensity[0] <Free.Free Base.F>_R <a>_R)
                       @ a
                       (Free.Pure @ Base.F @ a)
                 } in
                 \ w1 :: GHC.Types.Int ->
                 case Free.$wrun @ a w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
973707849b6184f6b55873f9317fc50b
  runCodensity :: Codensity.Codensity f a -> (a -> f b) -> f b
  RecSel Codensity.Codensity
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ (f :: * -> *) @ a @ b ds :: Codensity.Codensity f a ->
                 ds `cast` (Codensity.NTCo:Codensity[0] <f>_R <a>_R) @ b) -}
653e958aea297d1f5ff7ff70b1503c09
  toCodensity :: GHC.Base.Monad m => m a -> Codensity.Codensity m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Codensity.toCodensity1
                  `cast`
                (forall (m :: * -> *) a.
                 <GHC.Base.Monad m>_R
                 ->_R <m a>_R
                 ->_R Sym (Codensity.NTCo:Codensity[0] <m>_R <a>_R)) -}
933a13c7c5bd29bd255e64fed734be76
  toCodensity1 ::
    GHC.Base.Monad m => m a -> forall b. (a -> m b) -> m b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (m :: * -> *) @ a $dMonad :: GHC.Base.Monad m m1 :: m a @ b ->
                 GHC.Base.>>= @ m $dMonad @ a @ b m1) -}
instance GHC.Base.Applicative [Codensity.Codensity]
  = Codensity.$fApplicativeCodensity
instance GHC.Base.Functor [Codensity.Codensity]
  = Codensity.$fFunctorCodensity
instance GHC.Base.Monad [Codensity.Codensity]
  = Codensity.$fMonadCodensity
instance Base.MonadFree [., Codensity.Codensity]
  = Codensity.$fMonadFreefCodensity
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

